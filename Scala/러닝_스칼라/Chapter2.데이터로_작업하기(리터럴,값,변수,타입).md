### 소개
---
> 이 장에서는 스칼라의 핵심 데이터와 변수 타입을 다룬다.
> 먼저, literal, value, variable, type의 정의부터 알아보자.

- 리터럴은 숫자 5, 문자 A, 텍스트 "Hello, World"처럼 소스 코드에 바로 등장하는 데이터다.
- 값은 불변의 타입을 갖는 저장 단위다. 값은 정의될 때 데이터가 할당될 수 있지만, 절대 재할당될 수 는 없다.
- 변수는 가변의 타입을 갖는 저장 단위다. 변수는 정의 시 데이터를 할당할 수 있으며, 언제라도 데이터를 재할당할 수도 있다.
- 타입은 여러분이 작업하는 데이터의 종류로, 데이터의 정의 또는 분류를 의미한다. 스칼라의 모든 데이터는 특정 타입에 대응하며, 모든 스칼라 타입은 그 데이터를 처리하는 메소드를 갖는 클래스로 정의된다.

스칼라에서 값과 변수에 저장된 데이터를 더 이상 사용하지 않으면 JVM의 가비지 컬렉션이 자동으로 할당을 취소한다. 우리가 직접 할당 취소할 필요도, 그럴 능력도 없다.

### 변수 선언하기
---
- 스칼라의 값 구문 `val <이름>: <타입> = <리터럴>` 로 정의하며, 이 형태에 따라 타입이 `Int`인 이름 x를 만들고 여기에 숫자 5를 할당해보자.
- `scala> val x: Int = 5`

```linux
scala> x
x: Int = 5

scala> x * 2
res1: Int = 10

scala> x / 5
res2: Int = 1
```

- 이 '결과값'은 명시적으로 정의한 여느 값들과 마찬가지로 사용할 수 있다.
- 여기에 값 res0와 res1을 곱하면 그 결과로 값 50이 반환되고, 새로운 값 res3에 저장된다.

```linux
scala> res0 * res1
res3: Int = 50
```

- 이제 변수들을 가지고 작업해보자.
- 값과 달리 변수는 변경할 수 있으며, 새로운 값을 재할당할 수도 있다.
- 변수를 이용하여 작업하는 것을 예로 들어보면 다음과 같다.

```linux
scala> var a: Double = 2.72
a: Double = 2.72

scala> a = 355.0 / 113.0
a: Double = 3.1415929203539825

scala> a = 5
a: Double = 5.0
```

- double-precision floating-point number인 Double 타입을 가지는 변수 a를 정의하였다.
- 그리고 a는 변수이므로 여기에 다른 값을 재할당할 수 있다.

---
> 여기서는 간단하게 스칼라에서 값, 변수, 리터럴을 사용하는 법에 대해 소개하였다.
> 이 장의 나머지 부분에서는 각 주제별로 자세하게 다룰 것이다.

## 값
---
**값(value)** 는 불변의, 타입을 갖는 스토리지 단위이며, 관례적으로 데이터를 저장하는 기본적인 방법이다. `val` 키워드를 사용하여 새로운 값을 정의할 수 있다.

- 구문: 값 정의
	- `val <식별자>[: <타입>] = <데이터>`

- 값은 이름과 할당된 데이터 모두 필요하지만, 명시적 타입이 있어야 하는 것은 아니다.
- 타입이 지정되지 않았다면(즉, ': <타입>' 구문이 포함되지 않았다면), 스칼라 컴파일러는 할당된 데이터를 기반으로 타입을 추론한다.

- 스칼라 REPL에서 값을 정의하는 몇 가지 예를 들면 다음과 같다.
```linux
scala> val x: Int = 20
x: Int = 20

scala val greeting: String = "Hello, World"
greeting: String = Hello, World

scala> val atSymbol: Char = '@'
atSymbol: Char = @
```

- 구문 다이어그램을 통해 값 정의에서 타입을 지정하는 것이 선택사항임을 알아챘을 것이다.

- 값 할당을 기반으로 그 타입을 추론하는 것이 가능한 상황이라면, 값 정의에서 타입을 빼도 된다.
- 스칼라 컴파일러는 할당된 값을 보고 그 값의 타입을 알아차릴 것이다.
- 이를 **타입추론(Type Inference)** 이라고 한다.
- 값을 타입 없이 정의하더라도 타입이 없는 것이 아니며, 마치 타입을 지정하여 정의한 것처럼 적절한 타입을 할당한다.

- 타입을 지정하지 않은 예를 보자.
```linux
scala> val x = 20
x: Int = 20

scala> val greeting = "Hello, World"
greeting: String = Hello, World

scala> val atSymbol = '@'
atSymbol: Char = @
```

- 이 예제에서 값은 결국 타입이 명시적으로 기술되었을 때와 동일한 타입을 갖는다. 
- 스칼라 컴파일러는 REPL을 통해 리터럴 20은 타입 Int에, 리터럴 "Hello, World"는 String에, 리터럴 @은 타입 Char에 대응함을 추론할 수 있다.

- 스칼라의 타입 추론을 사용하면 명시적으로 값의 타입을 작성할 필요가 없기 때문에 코드를 작성할 때 유용하다.
- 다만, 코드의 가독성을 떨어뜨리지 않는 범위에서 사용해야 한다. 
- 누군가 작성한 코드를 읽으면서 그 값의 타입이 무엇인지 알아볼 수 없다면, 값 정의에 명시적 타입을 포함하는 것이 더 낫다.

- 타입 추론이 데이터를 저장하는 데 사용할 올바른 타입을 추론하겠지만, 설정한 명시적인 타입을 대체하지는 않는다.
- 초깃값과  호환되지 않는 타입으로 값을 정의하면 컴파일 에러가 발생한다.
```linux
scala> val x: Int = "Hello"
<console>:7: error: type mismatch;
 found  : String("Hello")
 required: Int
	 val x: Int = "Hello"
	              ^
```

## 변수
---
컴퓨터 과학에서 용어 **변수(variable)** 는 일반적으로 값을 저장하고 그 값을 가져올 수 있도록 할당되거나 예약된 메모리 공간에 대응하는 유일한 식별자를 의미한다. 메모리 공간이 예약되어 있는 동안에는 새로운 값을 할당할 수 있다. 따라서 메모리 공간의 내용은 동적이며 **가변적(variable)** 이다.

스칼라에서는 관례상 변수보다 값을 선호하는데, 이는 값을 사용하면 소스 코드가 안정적이며 예측할 수 있기 때문이다. 값을 정의하면 다른 어떤 코드에서 접근하더라도 같은 값을 유지한다. 코드 시작 부분에 값을 할당하면 코드 마지막 부분까지 값이 변경되지 않기 때문에 코드를 읽고 디버깅하는 일이 더 쉽다.
마지막으로, 애플리케이션 수명 기간에 사용할 수 있거나 동시 또는 멀티 스레드 코드에서 접근 가능한 데이터로 작업하는 경우, 변하지 않는 값은 예기치 않은 시점에 변경될 수도 있는 가변 데이터보다 더 안정적이며 에러가 발생할 경우도 적다.

- 임시 데이터를 저장하거나 루프 내에서 값을 누산하는 로컬 변수와 같이 변수가 더 적합한 경우라면 확실히 변수를 사용할 것이다.

- 주어진 이름, 타입, 할당으로 변수를 정의할 때는 `var` 키워드를 사용한다.

- 구문: 변수 정의
	- `var <식별자>[: 타입] = <데이터>`

- 값을 정의할 때와 마찬가지로, 변수도 명시적 타입 없이 정의할 수 있다.
- 만일 타입이 지정되지 않았다면, 스칼라 컴파일러는 변수에 할당할 올바른 타입을 결정하기 위해 타입 추론을 사용한다.
- 하지만 값과 달리, 변수는 아무 때나 새로운 데이터를 재할당할 수 있다.

- 변수를 정의하고 여기에 재할당하는 예로 그 변수와 다른 숫자를 곱해보자.
```linux
scala> var x = 5
x: Int = 5

scala> x = x * 4
x: Int = 20
```

- 변수에 재할당이 가능하다지만, 지정된 타입을 바꿀 수는 없으므로 그 변수의 타입과 호환되지 않는 타입의 데이터를 재할당할 수는 없다.
- 예를 들어, 타입 Int의 변수를 정의하고 여기에 String 값을 할당하면 컴파일러 에러가 발생한다.
```linux
scala> var x = 5
x: Int = 5

scala> x = "what's up?"
<console>:8: error: type mismatch;
 found : String("what\'s up?")
 required: Int
	 x = "what's up?"
	     ^
```

- 하지만 Double 타입 변수를 정의하고 여기에 Int 값을 할당하면, Int 숫자는 자동으로 Double 숫자로 전환될 수 있으므로 정상 동작한다.
```linux
scala> var y = 1.5
y: Double = 1.5

scala> y = 42
y: Double = 42.0
```


## 명명
---
스칼라 이름에는 문자, 숫자, 그리고 다양한 특수 연산자(operator) 기호를 사용할 수 있다. 따라서 좀 더 표현력 있는 코드를 작성할 수 있도록 더 긴 이름 대신 표준 수학 연산자(예:  +, -)와 상수(예: π 등)를 사용할 수 있다.

- 스칼라 언어 설명서는 이 연산자 기로를 "\u0020에서 \u007F 사이의 문자와 유니코드 Sm[Symbol/Math] 카테고리에서 대괄호와 마침표를 제외한 모든 문자"로 정의한다.
- 대괄호는 타입 매개변수화에 사용하도록 예약되어 있으며, 마침표는 객체(인스턴스화된 타입)의 필드와 메소드에 접근하기 위해 예약되어 있다.

- 스칼라에서 유효한 식별자를 만들기 위해 문자, 숫자, 기호를 조합하는 규칙은 다음과 같다.
	1. 하나의 문자 다음에는 아무것도 없거나, 하나 이상의 문자 또는 숫자가 뒤따라온다.
	2. 하나의 문자 뒤에는 아무것도 없거나 하나 이상의 문자와 숫자가 뒤따르며, 그 뒤에는 언더스코어(\_)를 덧붙일 수 있고, 그 다음에 하나 이상의 문자와 숫자 또는 연산 기호가 뒤따른다.
	3. 하나 또는 그 이상의 연산자 기호.
	4. 하나 또는 그 이상의 문자를 한 쌍의 backquote, \` 로 둘러싼다.

- REPL에서 이 명명 규칙을 시험해보자
```linux
// 특수 문자 'π'는 유효한 스칼라 식별자다.
scala> val π = 3.14159
val π: Double = 3.14159

scala> val $ = "USD currency symbol"
val $: String = USD currency symbol

scala> val o_O = "Hmm"
val o_O: String = Hmm

// 변수명은 숫자로 시작할 수 없다.
scala> val 50cent = "$0.50"
           ^
       error: invalid literal number

// 마침표는 연산자 기호가 아니다.
scala> val a.b = 25
           ^
       error: not found: value a

// backquote를 사용하면 마침표도 허용한다.
scala> val `a.b` = 4
val a.b: Int = 4
```

- 값과 변수명은 관례상 소문자로 시작하고, 추가적인 단어는 대문자로 시작한다.
- 이는 일반적으로 ComelCase라 불리며, 반드시 따라야 하는 것은 아니지만 모든 스칼라 개발자에게 권장되는 방식이다.
- 또한 타입/클래스는 대문자로 시작한다.
---


# 타입
---
스칼라에는 값과 변수를 정의할 때 사용하는 숫자 타입(예: Int, Double)과 숫자가 아닌 타입(예: String)이 있다. 이 핵심 타입은 객체 및 컬렉션을 포함하여 다른 모든 타입의 기본 요소가 되며, 그 자체도 자신의 데이터에 동작하는 메소드와 연산자를 갖는 객체가 된다.

- 자바, C와 달리 스칼라는 원시 데이터 타입의 개념이 없다. 
- JVM은 원시 정수 타입인 int와 정수 클래스 Integer를 지원하는 반면, 스칼라는 정수 클래스인 Int만 지원한다.

### 숫자형 데이터 타입
---
- 핵심 숫자형 데이터 타입
	- Byte
	- Short
	- Int
	- Long
	- Float
	- Double

- 스칼라는 타입 순위에 기반하여 한 타입의 숫자를 자동으로 다른 타입으로 전환해준다.
- 위의 숫자 타입들은 이 자동 전환 순서대로 정렬한 것으로, Byte 타입이 최하위에 있어 다른 모든 타입으로 전환될 수 있다.

- 이제 서로 다른 타입의 값을 생성하고 자동으로 그보다 높은 순위의 타입으로 전환해보자.
```linux
scala> val b: Byte = 10
val b: Byte = 10

scala> val s: Short = b
val s: Short = 10

scala> val d: Double = s
val d: Double = 10.0
```

- 여기서는 b와 s의 값은 더 높은 순위를 갖는 새로운 값에 할당되며, 따라서 자동으로 더 높은 순위로 전환된다.

> 자바 개발자는 이 타입들의 이름을 알 것이다. 이들은 동일한 이름의 핵심 JVM 타입의 Wrapper이다. JVM 타입을 감싸는 것은 스칼라와 자바가 상호작용이 가능하게 하며, 스칼라가 모든 자바 라이브러리를 사용할 수 있게 해준다.


- 스칼라는 높은 순위의 데이터 타입이 더 낮은 순위의 타입으로 자동 전환되는 것을 허용하지 않는다.