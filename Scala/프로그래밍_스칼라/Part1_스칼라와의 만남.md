### 목차
1. 스칼라를 간략히 소개하고, 구체적으로 맛볼 수 있는 몇 가지 예제를 다룬다.
2. 스칼라 프로그래밍의 기본 단위라고 할 수 있는 함수와 메서드, 리터럴 값, 클래스 등에 대해 다루면서 기본 문법 사항을 정리한다.
3. 2장에 이어서 기본 문법 사항을 정리한다. 연산자 오버로딩, if, for 내장, 루프 등에 대해 다룬다.


# 1.1 왜 스칼라인가?
---
스칼라는 최근 소프트웨어 개발자의 가려운 부분을 잘 긁어주는 언어이다. 스칼라는 간결하고 우아하며 유연한 문법을 사용하는 정적 타입의 다중 패러다임 JVM 언어로, 작은 인터프리터 방식의 스크립트부터 대규모의 복잡한 애플리케이션에 이르기까지 폭넓은 규모 확장성을 제공하는 여러 도구를 제공한다.

- JVM과 자바스크립트 언어
	- 스칼라는 JVM의 성능과 최적화를 활용함은 물론이고 자바를 중심으로 구축된 풍부한 기존 도구와 라이브러리 생태계도 이어 받음
	- 하지만 스칼라가 JVM에만 한정된 것은 아님

- 정적 타입
	- 스칼라는 튼튼한 애플리케이션을 만드는 도구로 정적 타입 지정을 채택함
	- 스칼라 타입 시스템은 자바 타입 시스템의 여러 단점을 고침
	- 타입 추론 (type inference)을 사용해서 대부분의 귀찮고 불필요한 타입 표기를 생략할 수 있게 지원함

- 다중 패러다임 - 함수형 프로그래밍
	- 스칼라는 함수형 프로그래밍(FP)을 완전히 지원함
	- FP는 동시성, 빅데이터, 일반적인 코드의 정확성을 사고하는 데 있어 최선의 도구임
	- Immutable Value, First Class, Side Effect가 없는 함수, 고차 함수, 함수 컬렉션 등은 모두 간결하고 강력하며 정확한 코드를 작성하는 데 기여함

- 복잡한 타입 시스템
	- 스칼라는 자바 타입 시스템을 더 유연한 제네릭스로 확장하고 코드 정확성을 높이기 위해 몇 가지 개선을 덧붙임
	- 타입 추론을 사용하는 스칼라 코드는 종종 동적 타입 언어만큼이나 간결함

- 간결하고 우아하며 유연한 문법
	- 번거롭고 긴 자바 코드가 스칼라에서는 간결한 구문으로 바뀜
	- 스칼라 기능을 활용하면, 도메인 특화 언어(Domain Specific Language)를 만들거나, 마치 '원래의' 스칼라 구문인 것처럼 느낄 수 있는 API를 제공함

- 규모 확장성 - 아키텍처
	- 스칼라를 사용하면 작은 인터프리터 방식의 스크립트부터 대규모의 복잡한 애플리케이션가지 작성할 수 있음
	-  네 가지 언어 메커니즘이 규모와 관계없이 시스템을 조합할 수 있도록 만들어줌
		1. 트레이트를 사용한 혼합 합성
		2. 추상 타입 멤버(Abstract Type Member)와 제네릭스
		3. 내포 클래스
		4. 명시적인 자기 타입 지정

### 1.1.1 스칼라의 매력
---
- 필자는 스칼라가 프로 개발자를 위한 언어라고 믿음
- 스칼라는 우리 분야의 프로들에게 필요한 다양한 기능과 고기능, 다양한 범주의 문제에 적합한 표현력을 갖춘 언어임
- 스칼라에 통달하기까지는 시간이 걸리겠지만, 일단 통달하고 나면 프로그래밍 언어로 인해 제약을 받는 일은 결코 없을 것임


### 1.1.2 자바 8이 나왔지만 여전히 유용한 스칼라
---
- 스칼라는 자바가 제공하는 것보다 더 강력한 타입 추론을 제공함
- 스칼라에  있는 강력한 패턴 매칭과 for comprehension은 코드 크기와 타입 간의 결합을 크게 줄임

---

# 1.2 스칼라 설치하기
---
1. 자바 설치
	- 오라클 웹 사이트에서 Java Development를 설치한다.
2. SBT 설치
	- 사실상 산업 표준 스칼라 빌드 도구인 SBT를 홈페이지에 따라 설치한다.
3. SBT 실행
	 - 셸이나 커맨드 창을 열고 코드 예제를 풀어둔 디렉터리로 이동한다. `sbt test` 를 입력하면 스칼라 컴파일러나 외부 라이브러리를 포함해서 해당 프로젝트가 의존하는 모든 라이브러리를 내려받는다.
	 - sbt는 코드를 컴파일한 다음 단위 테스트를 실행한다.

> 이제 시작할 준비가 되었다.


### 1.2.1 SBT 사용하기
---
- 여기서는 시작하는 데 필요한 기본적인 내용만 다룬다.
- sbt 명령을 시작할 때 어떤 작업을 수행할지 지정하지 않는다면, SBT는 대화형 REPL로 시작한다.
```linux
	> help     # 명령을 설명한다.
	> tasks    # 현재 사용 가능한 작업 중 가장 일반적으로 사용하는 것들을 보여준다.
	> tasks -V # 모든 가용 작업을 보여준다.
	> compile  # 코드를 증분 컴파일한다.
	> test     # 코드를 증분 컴파일하고 테스트를 실행한다.
	> clean    # 빌드로 산출된 결과물(중간 파일 등 포함)을 지운다.
	> ~test    # 저장된 파일이 바뀌면 증분 컴파일과 테스트를 진행한다.
	>          # 작업 앞에 '~'를 붙이면 프로젝트 파일을 감시하다가,
	>          # 일부 또는 전부가 변경되는 경우 작업을 실행한다는 뜻이다.
	> console  # 스칼라 REPL을 실행한다.
	> run      # 프로젝트의 'main' 루틴 중 하나를 실행한다.
	> show x   # 변수 'x'의 정의를 본다.
	> exit     # REPL을 종료한다.(= Ctrl-D)
```

- 나는 `~test` 를 사용해서 항상 변경 사항을 컴파일하고 관련 테스트를 실행함
- SBT는 증분 컴파일러(Incremental Compiler)와 테스트 실행기(Test Runner)를 사용함
- 매번 전체를 새로 빌드할 때까지 기다릴 필요가 없음
- `~test` 상태에서 다른 명령을 실행하거나 sbt를 종료하고 싶다면 리턴키를 누르면 됨

- `console` 을 실행하면 SBT는 먼저 프로젝트를 빌드하고 빌드한 프로젝트 결과를 CLASSPATH에 등록해서 스칼라가 사용할 수 있게 함
- 따라서 작성한 코드를 REPL에서 실험할 수 있음

> TIP.
> - 스칼라 REPL을 사용하면 API를 배우고 스칼라 코드의 관용구를 익히는 데 매우 효율적이다.
> - 심지어 자바 API도 익힐 수 있다.
> - SBT에서 console로 스칼라 REPL을 시작하면 프로젝트 의존관계와 컴파일한 프로젝트를 모두 CLASSPATH에 등록해주기 때문에 편리하다.


### 1.2.2 스칼라 명령행 도구 실행하기
---
- 스칼라 명령행 도구를 별도로 설치했다면 , 자바 컴파일러 javac와 비슷하게 scalac라는 명령으로 스칼라 컴파일러를 사용할 수 있다.
- 이 책에서는 직접 컴파일러를 사용하지는 않고 SBT를 활용해 빌드할 것이다.

- scalac를 사용한 커맨드라인
	```linux
	$ scalac -version
	$ scalac -help
	```

- scala를 사용한 커맨드라인
	```linux
	$ scala -version
	$ scala -help
	```

- 때떄로 scala를 사용해서 스칼라 '스크립트' 파일을 실행할 것이다.
- java 명령에는 이런 기능이 없다.
- 코드 예제에서 다음 스크립트를 살펴보자.
```scala
	// src/main/scala/progscala2/introscala/upper1.sc
	
	class Upper {
		def upper(strings: String*): Seq[String] = {
			strings.map((s: String) => s.toUpperCase())
		}
	}
	
	val up = new Upper
	println(up.upper("Hello", "World!"))
```

- scala 명령으로 실행한다.
	```linux
	$ scala path/upper1.sc
	ArrayBuffer(HELLO, WORLD!)
	```

- 다음은 몇 가지 유용한 명령을 보여주는 REPL 세션이다.
```linux
	$ scala
	scala> :help

	scala> val s = "Hello, World!"
	s: String = Hello, World!

	scala> println("Hello, World!")
	Hello, World!

	scala> 1 + 2
	res3: Int = 3

	scala> s.con<tab>
	concat    contains    contentEquals

	scala> s.contains("el")
	res4: Boolean = true

	scala> :quit
	$   # 다시 shell로 돌아옴
```

---
# 1.3 스칼라 맛보기

> 1장의 나머지와 이어지는 2, 3장에 걸쳐 여러 스칼라 기능을 빠르게 살펴볼 것이다.

- IDE를 사용하지 않는다면 가능한 SBT를 사용하길 권한다. 
- 실제로 IDE를 더 선호한다고 해도, 커맨드 창에서 SBT를 한번 실행해서 모양을 살피라.
- 이 책의 저자는 IDE를 거의 사용하지 않는다고 한다.

- 셸 창에서 코드 에제의 최상위 디렉터리로 이동한 다음 sbt를 시작하자.
```scala
	val book = "Programming Scala"
	// book: java.lang.String = Programming Scala
	
	println(book)
	// Programming Scala
```

- `val book = "Programming Scala"`
	- `val` 키워드를 사용해서 불변 Immutable 변수 book을 선언했다.
	- 변경 가능한 데이터를 사용하는 것이 일반적인 버그의 원인 중 하나인 만큼 불변값을 사용하길 권장한다.
	- 스칼라는 Literal값인 "Programming Scala"로부터 book의 타입이 `java.lang.String` 임을 추론해낸다.

	- 타입 정보를 보여주거나, 선언에 명시적으로 타입 정보를 추가하는 경우, 대상 이름 뒤에 콜론(:)을 붙인 다음 타입 표기(type annotation)를 추가한다.

- 스칼라의 타입 표기 방식이 자바의 관례를 따르지 않는 이유가 무엇일까 ?
	- 스칼라에서는 타입 정보가 추론되는 경우가 많다. 따라서 코드에서 반드시 타입을 명시할 필요는 없다.
	- 자바의 type item과 비교해서 `item: type` 방식은 콜론과 타입 표기를 생략하고 그냥 `item` 이라고 쓴 경우와는 다르게 컴파일러 구문분석의 모호함을 없애준다.

- 일반적인 규칙으로, 스칼라는 자바 문법을 사용하는 경우 새로운 기능을 지원하기 어렵다는 등의 그럴듯한 이유가 있는 경우에만 자바 문법과 다른 방식을 택한다.


- REPL만 사용하는 경우 길이가 긴 예제를 수정하고 다시 실행하는 과정이 번거롭다.
- 따라서 텍스트 편집기나 IDE에서 스칼라 스크립트를 작성하는 것이 편하다.
- 그 다음에 스크립트에 실행하거나 코드를 통째로 REPL에 복사해 넣을 수 있다.

- 이 책에서는 스크립트 파일의 확장자가 .sc인 반면 컴파일할 코드는 .scala로 정해져있다.
- 만약 확장자를 .scala로 정하면 SBT가 프로젝트를 빌드할 때 스크립트까지 컴파일하려 시도할 것이고, 스크립트는 컴파일할 수 없다.

- sbt를 시작하고 console을 실행해서 스칼라를 시작하자.
- 그 다음에 :load 명령을 사용해서 파일을 로드(컴파일 후 실행)하자.
```linux
	scala> :load path/upper1.sc
	ArrayBuffer(HELLO, WORLD!)
```

- 스크립트를 컴파일할 수 없는 이유
	- 스크립트는 단순하게 쓸 수 있도록 설계되었고, 그런 단순화 중 하나는 자바나 스칼라 코드에서와 달리 선언(변수나 함수)을 객체로 감쌀 필요가 없다는 것이다(객체로 감싸는 것은 JVM의 요구 사항이다).
	- `scala` 명령은 이런 상충되는 두 가지 조건을 해결하기 위해 교묘한 방법을 사용한다.
	- 즉, 스크립트를 여러분이 볼 수 없는 익명 객체로 둘러싼다.

	- 정말로 스크립트를 JVM 바이트 코드(여러 `*.class` 파일)로 컴파일하고 싶다면 `scalac -Xscript <object>` 인자를 지정해야 한다.
	- `<object>` 는 원하는 객체의 이름으로, 만들어질 자바 애플리케이션의 'main' 클래스의 이름이 된다.

```linux
	$ scalac -Xscript Upper1 path/upper1.sc
	$ scala Upper1
	ArrayBuffer(HELLO, WORLD!)
```

- 현재 디렉터리를 살펴보면 몇 가지 우스운 이름의 `*.class` 파일을 볼 수 있다.
- (힌트: 일부는 **익명 함수**를 객체로 반환한 결과이다.)
- `javap` 와 그에 상응하는 `scalap` 를 사용해서 역공학해보자.
```linux
$ javap -cp . Upper1
Compiled from "upper1.sc"
public final class Upper1 {
	public static void main(java.lang.String[]);
}
$ scalap -cp . Upper1
object Upper1 extends scala.AnyRef {
	def this() = { /* Compiled Code */ }
	def main(argv: scala.Array[scala.Predef.String]): scala.Unit =
		{ /* Compiled Code */ }
}
```

- 다시 코드를 본다.
```scala
// path/upper1.sc

class Upper {
	def upper(strings: String*): Seq[String] = {
		strings.map((s: String) => s.toUpperCase())
	}
}

val up = new Upper
println(up.upper("Hello", "World!"))
```

- Upper 클래스에 있는 upper 메서드는 하나 이상의 입력 문자열을 대문자로 바꿔서 Seq로 반환한다.
- 마지막 두 줄은 Upper의 인스턴스를 만들고 문자열 "Hello"와 "World!"를 대문자로 바꾼 다음, 결과로 얻은 Seq를 마지막에 출력한다.

- 스칼라에서 클래스는 `class` 키워드로 시작하며, 전체 클래스 본문은 중괄호 사이에 위치한다.
- 실제로는 클래스의 본문이 그 클래스의 주 생성자(Primary Constructor)다.
- 이 생성자가 매개변수를 받아야 한다면 클래스 이름 Upper 뒤에 매개변수 목록을 추가할 수 있다.


- 다음 코드는 메서드 정의를 시작한다.

```scala
def upper(strings: String*): Seq[String] = ...
```
- 메서드 정의는 `def` 키워드로 시작하며, 그 다음에 메서드 이름이 온다.
- 메서드 이름 다음에는 선택적으로 매개변수 목록이 온다.
- 그 뒤에 선택적으로 반환 타입이 올 수 있다(많은 경우 반환 타입을 컴파일러가 추론할 수 있다.)
- 반환 타입은 콜론 뒤에 타입을 붙여 표시한다.
- 마지막 = 가 메서드 시그니처와 본문 사이에 온다.

- 괄호로 둘러싸인 매개변수 목록은 실제로는 String으로 이루어진 **가변 길이 매개변수 목록**이다.
- `strings` 매개변수 뒤에 있는 타입 표기에서 `String` 뒤에 `*` 를 붙인 것은 가변 길이 인자 목록을 의미한다.
- 따라서 원하는 만큼 문자열을 콤마(,)로 분리해서 인자로 넘길 수 있다.
- 메서드 안에서 `strings` 매개변수의 타입은 실제로는 자바 배열을 감싼 WrapperedArray이다.

- 메서드의 반환 타입이 매개변수 목록 다음에 온다.
- 이 예제에서 반환 타입은 `Seq[String]` 으로 Seq는 (순서를 보장하지 않는 Set이나 Map이 임의로 원소를 돌려주는 것과 반대로) 일정한 순서로 반복가능한 추상적 컬렉션이다.
- 이 메서드가 실제 반환하는 타입은 scala.collection.mutable.ArrayBuffer지만, 대부분의 경우 호출하는 쪽에서 거기까지 알 필요는 없다.

- Seq가 자바의 제네릭 타입과 마찬가지로 매개변수화한 타입이라는 사실에 유의하자.
- Seq는 '어떤 것의 시퀀스'로, 여기서는 문자열의 시퀀스다.
- 매개변수화한 타입을 지정할 때 자바에서는 <>를 사용하지만 스칼라에서는 []를 사용한다.

- upper 메서드의 본문이 `=` 다음에 온다.
- 등호가 들어가는 한 가지 이유는 모호성을 줄이기 위해서이다.
- 대부분의 경우 스칼라는 메서드의 반환 타입을 추론할 수 있다.
- 등호를 사용하면 메서드가 매개변수를 받지 않는 경우 매개변수 목록을 생략할 수 있다.

- 등호는 값이나 함수가 더 깊이 연관된 개념이라는 함수형 프로그래밍의 원칙을 강조하기 위함이기도 하다.

```scala
(s: String) => s.toUpperCase()
```

- 매개변수 목록에는 s라는 이름의 String 매개변수만 들어 있다.
- 함수 리터럴의 본문은 '화살표' => 다음에 나온다.
- 본문은 s에 대해 `toUpperCase()`를 호출한다.
- 이 호출의 결과가 자동으로 함수 리터럴의 결과로 반환된다.
- 스칼라에서는 함수나 메서드의 가장 마지막 식이 반환값이 된다.

```scala
// path/upper2.sc

	object Upper {
		def upper(strings: String*) = strings.map(_.toUpperCase())
	}
	
	println(Upper.upper("Hello", "World!"))
```

- 첫 줄에서는 `Upper`를 `object`로 선언했다.
- 이는 싱글턴 객체이다. 스칼라는 디자인 패턴을 언어의 1급 요소로 받아들였다.
- 클래스처럼 선언했지만, 스칼라 실행 환경은 Upper 인스턴스를 오직 하나만 생성한다.
- 다른 언어에서 '클래스 수준'의 멤버를 활용해야 하는 경우 스칼라에서는 object를 사용한다.
- 여기서는 Upper에 별도의 상태가 들어있지 않기 때문에, 실제로 인스턴스가 둘 이상 필요하지 않다. 따라서 싱글턴으로 충분하다.



### 스칼라가 static을 지원하지 않는 이유는 뭘까?
---
- 정적 멤버를 지원하는 언어와 비교해보면, 스칼라는 **모든 것**이 객체여야 한다는 목표에 더 가까운 언어이다.
- 정적 클래스 멤버와 **인스턴스** 클래스 멤버를 섞어 쓰는 언어에 비해 `object` 를 사용하면 이러한 정책을 더 일관성 있게 지킬 수 있다.
- 자바의 `static` 메서드나 필드는 특정 타입의 실제 인스턴스와 연관이 없음을 기억해야 한다.
- 스칼라의 `object` 는 어떤 타입의 유일한 인스턴스이다.



- 두 번째 줄의 upper 구현도 단순해졌다. 
- 스칼라는 보통 메서드의 반환 타입을 추론할 수 있기 때문에 명시적인 반환 타입 표기를 없앴다.
- 또한 메서드 본문에 식이 하나만 들어 있기 때문에 불필요한 중괄호도 없앴고, 메서드 정의 전체를 한 줄로 썼다.
- 메서드 본문 바로 앞의 등호는 컴파일러뿐 아니라 코드를 읽는 사람에게도 메서드 본문이 어디서 시작하는지 알려준다.

- 스칼라가 인자의 타입을 추론하지 못하는 이유는 기술적인 문제이다. 스칼라의 타입 추론 알고리즘은 지역 타입 추론(local type inference)이다.
- 이는 전체 프로그램을 대상으로 타입을 추론하지 않고, 일정 영역 내에서 지역적으로 작동한다는 뜻이다.



- 또한 함수 리터럴에서도 축약형을 사용했다. 이전 예제는 다음과 같이 작성했다.

```scala
(s: String) => s.toUpperCase()
```

- 지금은 다음과 같은 식을 사용해서 이를 더 축약했다.

```scala
_.toUpperCase()
```



- map 메서드는 인자로 함수를 하나 받는다. 인자 함수 자체도 인자를 오직 하나만 받는다.
- 따라서 이름을 붙인 매개변수 대신 '위치지정자(placeholder)'인 _를 사용할 수 있다.
- 즉, _는 익명 변수처럼 작동하며, 변수에 문자열이 대입된 다음, 변수에 대해 `toUpperCase`를 호출한다.
- 스칼라는 익명 변수의 타입이 String이라는 것도 추론한다.



